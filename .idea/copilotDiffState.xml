<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/waterfountainmachine/app/hardware/sdk/ProtocolFrame.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/waterfountainmachine/app/hardware/sdk/ProtocolFrame.kt" />
              <option name="originalContent" value="package com.waterfountainmachine.app.hardware.sdk&#10;&#10;import java.nio.ByteBuffer&#10;import java.nio.ByteOrder&#10;&#10;/**&#10; * Represents a VMC communication protocol frame&#10; * Frame format: [ADDR][FRAME_NUMBER][HEADER][CMD][DATA_LENGTH][DATA][CHK]&#10; */&#10;data class ProtocolFrame(&#10;    val address: Byte = FIXED_ADDRESS,&#10;    val frameNumber: Byte = FIXED_FRAME_NUMBER,&#10;    val header: Byte,&#10;    val command: Byte,&#10;    val dataLength: Byte,&#10;    val data: ByteArray,&#10;    val checksum: Byte&#10;) {&#10;    companion object {&#10;        const val FIXED_ADDRESS: Byte = 0xFF.toByte()&#10;        const val FIXED_FRAME_NUMBER: Byte = 0x00&#10;        const val APP_HEADER: Byte = 0x55&#10;        const val VMC_HEADER: Byte = 0xAA.toByte()&#10;        &#10;        // Minimum frame size: ADDR + FRAME_NUMBER + HEADER + CMD + DATA_LENGTH + CHK&#10;        const val MIN_FRAME_SIZE = 6&#10;        const val MAX_DATA_SIZE = 255&#10;    }&#10;&#10;    /**&#10;     * Convert frame to byte array for transmission&#10;     */&#10;    fun toByteArray(): ByteArray {&#10;        val frameSize = MIN_FRAME_SIZE + data.size&#10;        val buffer = ByteBuffer.allocate(frameSize).order(ByteOrder.LITTLE_ENDIAN)&#10;        &#10;        buffer.put(address)&#10;        buffer.put(frameNumber)&#10;        buffer.put(header)&#10;        buffer.put(command)&#10;        buffer.put(dataLength)&#10;        buffer.put(data)&#10;        buffer.put(checksum)&#10;        &#10;        return buffer.array()&#10;    }&#10;&#10;    /**&#10;     * Calculate checksum for this frame&#10;     * Checksum = sum of all bytes except ADDR, FRAME_NUMBER, and CHK (lower 8 bits)&#10;     */&#10;    fun calculateChecksum(): Byte {&#10;        var sum = (header.toInt() and 0xFF) +&#10;                  (command.toInt() and 0xFF) +&#10;                  (dataLength.toInt() and 0xFF)&#10;&#10;        for (b in data) {&#10;            sum += (b.toInt() and 0xFF)&#10;        }&#10;&#10;        return (sum and 0xFF).toByte()&#10;    }&#10;&#10;    /**&#10;     * Validate frame checksum&#10;     */&#10;    fun isValid(): Boolean {&#10;        return checksum == calculateChecksum()&#10;    }&#10;&#10;    override fun equals(other: Any?): Boolean {&#10;        if (this === other) return true&#10;        if (javaClass != other?.javaClass) return false&#10;&#10;        other as ProtocolFrame&#10;&#10;        if (address != other.address) return false&#10;        if (frameNumber != other.frameNumber) return false&#10;        if (header != other.header) return false&#10;        if (command != other.command) return false&#10;        if (dataLength != other.dataLength) return false&#10;        if (!data.contentEquals(other.data)) return false&#10;        if (checksum != other.checksum) return false&#10;&#10;        return true&#10;    }&#10;&#10;    override fun hashCode(): Int {&#10;        var result = address.toInt()&#10;        result = 31 * result + frameNumber.toInt()&#10;        result = 31 * result + header.toInt()&#10;        result = 31 * result + command.toInt()&#10;        result = 31 * result + dataLength.toInt()&#10;        result = 31 * result + data.contentHashCode()&#10;        result = 31 * result + checksum.toInt()&#10;        return result&#10;    }&#10;}&#10;&#10;/**&#10; * Builder for creating protocol frames&#10; */&#10;class ProtocolFrameBuilder {&#10;    private var header: Byte = ProtocolFrame.APP_HEADER&#10;    private var command: Byte = 0&#10;    private var data: ByteArray = byteArrayOf()&#10;&#10;    fun appHeader() = apply { header = ProtocolFrame.APP_HEADER }&#10;    fun vmcHeader() = apply { header = ProtocolFrame.VMC_HEADER }&#10;    fun command(cmd: Byte) = apply { command = cmd }&#10;    fun data(data: ByteArray) = apply { this.data = data }&#10;    fun dataBytes(vararg bytes: Byte) = apply { this.data = bytes }&#10;&#10;    fun build(): ProtocolFrame {&#10;        val dataLength = (data.size and 0xFF).toByte()&#10;        val frame = ProtocolFrame(&#10;            header = header,&#10;            command = command,&#10;            dataLength = dataLength,&#10;            data = data,&#10;            checksum = 0 // Temporary&#10;        )&#10;&#10;        return frame.copy(checksum = frame.calculateChecksum())&#10;    }&#10;}&#10;&#10;/**&#10; * Parser for incoming protocol frames&#10; */&#10;object ProtocolFrameParser {&#10;&#10;    /**&#10;     * Parse byte array into ProtocolFrame&#10;     * @param bytes Raw bytes received from VMC&#10;     * @return Parsed frame or null if invalid&#10;     */&#10;    fun parse(bytes: ByteArray): ProtocolFrame? {&#10;        if (bytes.size &lt; ProtocolFrame.MIN_FRAME_SIZE) {&#10;            return null&#10;        }&#10;&#10;        val buffer = ByteBuffer.wrap(bytes).order(ByteOrder.LITTLE_ENDIAN)&#10;&#10;        val address = buffer.get()&#10;        val frameNumber = buffer.get()&#10;        val header = buffer.get()&#10;        val command = buffer.get()&#10;        val dataLength = buffer.get()&#10;&#10;        val dataSize = dataLength.toInt() and 0xFF&#10;        if (buffer.remaining() &lt; dataSize + 1) { // +1 for checksum&#10;            return null&#10;        }&#10;&#10;        val data = ByteArray(dataSize)&#10;        buffer.get(data)&#10;        val checksum = buffer.get()&#10;&#10;        val frame = ProtocolFrame(&#10;            address = address,&#10;            frameNumber = frameNumber,&#10;            header = header,&#10;            command = command,&#10;            dataLength = dataLength,&#10;            data = data,&#10;            checksum = checksum&#10;        )&#10;&#10;        return if (frame.isValid()) frame else null&#10;    }&#10;}&#10;&#10;&#10;&#10;&#10;" />
              <option name="updatedContent" value="package com.waterfountainmachine.app.hardware.sdk&#10;&#10;import java.nio.ByteBuffer&#10;import java.nio.ByteOrder&#10;&#10;/**&#10; * Represents a VMC communication protocol frame&#10; * Frame format: [ADDR][FRAME_NUMBER][HEADER][CMD][DATA_LENGTH][DATA][CHK]&#10; */&#10;data class ProtocolFrame(&#10;    val address: Byte = FIXED_ADDRESS,&#10;    val frameNumber: Byte = FIXED_FRAME_NUMBER,&#10;    val header: Byte,&#10;    val command: Byte,&#10;    val dataLength: Byte,&#10;    val data: ByteArray,&#10;    val checksum: Byte&#10;) {&#10;    companion object {&#10;        const val FIXED_ADDRESS: Byte = 0xFF.toByte()&#10;        const val FIXED_FRAME_NUMBER: Byte = 0x00&#10;        const val APP_HEADER: Byte = 0x55&#10;        const val VMC_HEADER: Byte = 0xAA.toByte()&#10;        &#10;        // Minimum frame size: ADDR + FRAME_NUMBER + HEADER + CMD + DATA_LENGTH + CHK&#10;        const val MIN_FRAME_SIZE = 6&#10;        const val MAX_DATA_SIZE = 255&#10;    }&#10;&#10;    /**&#10;     * Convert frame to byte array for transmission&#10;     */&#10;    fun toByteArray(): ByteArray {&#10;        val frameSize = MIN_FRAME_SIZE + data.size&#10;        val buffer = ByteBuffer.allocate(frameSize).order(ByteOrder.LITTLE_ENDIAN)&#10;        &#10;        buffer.put(address)&#10;        buffer.put(frameNumber)&#10;        buffer.put(header)&#10;        buffer.put(command)&#10;        buffer.put(dataLength)&#10;        buffer.put(data)&#10;        buffer.put(checksum)&#10;        &#10;        return buffer.array()&#10;    }&#10;&#10;    /**&#10;     * Calculate checksum for this frame&#10;     * Checksum = sum of all bytes except ADDR, FRAME_NUMBER, and CHK (lower 8 bits)&#10;     */&#10;    fun calculateChecksum(): Byte {&#10;        var sum = (header.toInt() and 0xFF) + &#10;                  (command.toInt() and 0xFF) + &#10;                  (dataLength.toInt() and 0xFF)&#10;        &#10;        for (b in data) {&#10;            sum += (b.toInt() and 0xFF)&#10;        }&#10;        &#10;        return (sum and 0xFF).toByte()&#10;    }&#10;&#10;    /**&#10;     * Validate frame checksum&#10;     */&#10;    fun isValid(): Boolean {&#10;        return checksum == calculateChecksum()&#10;    }&#10;&#10;    override fun equals(other: Any?): Boolean {&#10;        if (this === other) return true&#10;        if (javaClass != other?.javaClass) return false&#10;&#10;        other as ProtocolFrame&#10;&#10;        if (address != other.address) return false&#10;        if (frameNumber != other.frameNumber) return false&#10;        if (header != other.header) return false&#10;        if (command != other.command) return false&#10;        if (dataLength != other.dataLength) return false&#10;        if (!data.contentEquals(other.data)) return false&#10;        if (checksum != other.checksum) return false&#10;&#10;        return true&#10;    }&#10;&#10;    override fun hashCode(): Int {&#10;        var result = address.toInt()&#10;        result = 31 * result + frameNumber.toInt()&#10;        result = 31 * result + header.toInt()&#10;        result = 31 * result + command.toInt()&#10;        result = 31 * result + dataLength.toInt()&#10;        result = 31 * result + data.contentHashCode()&#10;        result = 31 * result + checksum.toInt()&#10;        return result&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/waterfountainmachine/app/hardware/sdk/ProtocolFrameBuilder.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/waterfountainmachine/app/hardware/sdk/ProtocolFrameBuilder.kt" />
              <option name="updatedContent" value="package com.waterfountainmachine.app.hardware.sdk&#10;&#10;/**&#10; * Builder for creating protocol frames&#10; */&#10;class ProtocolFrameBuilder {&#10;    private var header: Byte = ProtocolFrame.APP_HEADER&#10;    private var command: Byte = 0x00&#10;    private var data: ByteArray = byteArrayOf()&#10;&#10;    fun appHeader(): ProtocolFrameBuilder {&#10;        header = ProtocolFrame.APP_HEADER&#10;        return this&#10;    }&#10;&#10;    fun vmcHeader(): ProtocolFrameBuilder {&#10;        header = ProtocolFrame.VMC_HEADER&#10;        return this&#10;    }&#10;&#10;    fun command(cmd: Byte): ProtocolFrameBuilder {&#10;        command = cmd&#10;        return this&#10;    }&#10;&#10;    fun data(data: ByteArray): ProtocolFrameBuilder {&#10;        this.data = data.copyOf()&#10;        return this&#10;    }&#10;&#10;    fun dataBytes(vararg bytes: Byte): ProtocolFrameBuilder {&#10;        this.data = bytes&#10;        return this&#10;    }&#10;&#10;    fun build(): ProtocolFrame {&#10;        val dataLength = data.size.toByte()&#10;        &#10;        // Calculate checksum: header + command + dataLength + data&#10;        var checksum = (header.toInt() and 0xFF) + &#10;                      (command.toInt() and 0xFF) + &#10;                      (dataLength.toInt() and 0xFF)&#10;        &#10;        for (b in data) {&#10;            checksum += (b.toInt() and 0xFF)&#10;        }&#10;        &#10;        val finalChecksum = (checksum and 0xFF).toByte()&#10;&#10;        return ProtocolFrame(&#10;            address = ProtocolFrame.FIXED_ADDRESS,&#10;            frameNumber = ProtocolFrame.FIXED_FRAME_NUMBER,&#10;            header = header,&#10;            command = command,&#10;            dataLength = dataLength,&#10;            data = data.copyOf(),&#10;            checksum = finalChecksum&#10;        )&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/waterfountainmachine/app/hardware/sdk/ProtocolFrameParser.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/waterfountainmachine/app/hardware/sdk/ProtocolFrameParser.kt" />
              <option name="updatedContent" value="package com.waterfountainmachine.app.hardware.sdk&#10;&#10;import java.nio.ByteBuffer&#10;import java.nio.ByteOrder&#10;&#10;/**&#10; * Parser for protocol frames from byte arrays&#10; */&#10;object ProtocolFrameParser {&#10;    &#10;    /**&#10;     * Parse byte array into ProtocolFrame&#10;     * @param bytes Raw bytes received from VMC&#10;     * @return Parsed frame or null if invalid&#10;     */&#10;    fun parse(bytes: ByteArray): ProtocolFrame? {&#10;        if (bytes.size &lt; ProtocolFrame.MIN_FRAME_SIZE) {&#10;            return null&#10;        }&#10;        &#10;        try {&#10;            val buffer = ByteBuffer.wrap(bytes).order(ByteOrder.LITTLE_ENDIAN)&#10;            &#10;            val address = buffer.get()&#10;            val frameNumber = buffer.get()&#10;            val header = buffer.get()&#10;            val command = buffer.get()&#10;            val dataLength = buffer.get()&#10;            &#10;            val dataLengthInt = dataLength.toInt() and 0xFF&#10;            if (buffer.remaining() &lt; dataLengthInt + 1) { // +1 for checksum&#10;                return null&#10;            }&#10;            &#10;            val data = ByteArray(dataLengthInt)&#10;            if (dataLengthInt &gt; 0) {&#10;                buffer.get(data)&#10;            }&#10;            &#10;            val checksum = buffer.get()&#10;            &#10;            val frame = ProtocolFrame(&#10;                address = address,&#10;                frameNumber = frameNumber,&#10;                header = header,&#10;                command = command,&#10;                dataLength = dataLength,&#10;                data = data,&#10;                checksum = checksum&#10;            )&#10;            &#10;            return if (frame.isValid()) frame else null&#10;            &#10;        } catch (e: Exception) {&#10;            return null&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/waterfountainmachine/app/hardware/sdk/TestRunner.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/waterfountainmachine/app/hardware/sdk/TestRunner.kt" />
              <option name="updatedContent" value="package com.waterfountainmachine.app.hardware.sdk&#10;&#10;import kotlinx.coroutines.runBlocking&#10;&#10;/**&#10; * Simple test runner to verify our SDK implementation works&#10; * This bypasses the Gradle test configuration issue&#10; */&#10;fun main() {&#10;    println(&quot; Running VMC SDK Tests...&quot;)&#10;    &#10;    // Test 1: Protocol Frame Creation and Validation&#10;    println(&quot;\n1️⃣ Testing Protocol Frame Creation...&quot;)&#10;    testProtocolFrameCreation()&#10;    &#10;    // Test 2: VMC Command Builder&#10;    println(&quot;\n2️⃣ Testing VMC Command Builder...&quot;)&#10;    testVmcCommandBuilder()&#10;    &#10;    // Test 3: SDK Basic Operations&#10;    println(&quot;\n3️⃣ Testing SDK Basic Operations...&quot;)&#10;    testSDKOperations()&#10;    &#10;    println(&quot;\n✅ All tests completed!&quot;)&#10;}&#10;&#10;fun testProtocolFrameCreation() {&#10;    try {&#10;        // Create a test frame&#10;        val frame = ProtocolFrameBuilder()&#10;            .appHeader()&#10;            .command(0x31)&#10;            .dataBytes(0xAD.toByte())&#10;            .build()&#10;        &#10;        // Verify frame structure&#10;        assert(frame.address == ProtocolFrame.FIXED_ADDRESS) { &quot;Wrong address&quot; }&#10;        assert(frame.header == ProtocolFrame.APP_HEADER) { &quot;Wrong header&quot; }&#10;        assert(frame.command == 0x31.toByte()) { &quot;Wrong command&quot; }&#10;        assert(frame.dataLength == 1.toByte()) { &quot;Wrong data length&quot; }&#10;        assert(frame.data.contentEquals(byteArrayOf(0xAD.toByte()))) { &quot;Wrong data&quot; }&#10;        assert(frame.isValid()) { &quot;Frame validation failed&quot; }&#10;        &#10;        println(&quot;   ✅ Protocol frame creation and validation works correctly&quot;)&#10;    } catch (e: Exception) {&#10;        println(&quot;   ❌ Protocol frame test failed: ${e.message}&quot;)&#10;    }&#10;}&#10;&#10;fun testVmcCommandBuilder() {&#10;    try {&#10;        // Test getDeviceId command&#10;        val deviceIdFrame = VmcCommandBuilder.getDeviceId()&#10;        assert(deviceIdFrame.command == VmcCommands.GET_DEVICE_ID) { &quot;Wrong device ID command&quot; }&#10;        assert(deviceIdFrame.isValid()) { &quot;Device ID frame invalid&quot; }&#10;        &#10;        // Test delivery command&#10;        val deliveryFrame = VmcCommandBuilder.deliveryCommand(5, 2)&#10;        assert(deliveryFrame.command == VmcCommands.DELIVERY_COMMAND) { &quot;Wrong delivery command&quot; }&#10;        assert(deliveryFrame.data.contentEquals(byteArrayOf(5, 2))) { &quot;Wrong delivery data&quot; }&#10;        assert(deliveryFrame.isValid()) { &quot;Delivery frame invalid&quot; }&#10;        &#10;        // Test remove fault command&#10;        val faultFrame = VmcCommandBuilder.removeFault()&#10;        assert(faultFrame.command == VmcCommands.REMOVE_FAULT) { &quot;Wrong fault command&quot; }&#10;        assert(faultFrame.isValid()) { &quot;Fault frame invalid&quot; }&#10;        &#10;        println(&quot;   ✅ VMC command builder works correctly&quot;)&#10;    } catch (e: Exception) {&#10;        println(&quot;   ❌ VMC command builder test failed: ${e.message}&quot;)&#10;    }&#10;}&#10;&#10;fun testSDKOperations() = runBlocking {&#10;    try {&#10;        // Create mock serial communicator&#10;        val mockSerial = MockSerialCommunicator()&#10;        val sdk = VendingMachineSDKImpl(mockSerial)&#10;        &#10;        // Test connection&#10;        val connected = sdk.connect()&#10;        assert(connected) { &quot;Connection failed&quot; }&#10;        assert(sdk.isConnected()) { &quot;Not showing as connected&quot; }&#10;        &#10;        // Test getDeviceId with mock response&#10;        val deviceId = &quot;WF001234567890\u0000&quot;&#10;        val responseFrame = ProtocolFrameBuilder()&#10;            .vmcHeader()&#10;            .command(VmcCommands.GET_DEVICE_ID)&#10;            .data(deviceId.toByteArray(Charsets.UTF_8).take(15).toByteArray())&#10;            .build()&#10;        mockSerial.queueResponse(responseFrame.toByteArray())&#10;        &#10;        val result = sdk.getDeviceId()&#10;        assert(result.isSuccess) { &quot;getDeviceId failed: ${result.exceptionOrNull()?.message}&quot; }&#10;        &#10;        // Test delivery command&#10;        val deliveryResponseFrame = ProtocolFrameBuilder()&#10;            .vmcHeader()&#10;            .command(VmcCommands.DELIVERY_COMMAND)&#10;            .dataBytes(5, 2)&#10;            .build()&#10;        mockSerial.queueResponse(deliveryResponseFrame.toByteArray())&#10;        &#10;        val deliveryResult = sdk.sendDeliveryCommand(5, 2)&#10;        assert(deliveryResult.isSuccess) { &quot;sendDeliveryCommand failed: ${deliveryResult.exceptionOrNull()?.message}&quot; }&#10;        &#10;        // Test disconnect&#10;        sdk.disconnect()&#10;        assert(!sdk.isConnected()) { &quot;Still showing as connected after disconnect&quot; }&#10;        &#10;        println(&quot;   ✅ SDK operations work correctly&quot;)&#10;    } catch (e: Exception) {&#10;        println(&quot;   ❌ SDK operations test failed: ${e.message}&quot;)&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/waterfountainmachine/app/hardware/sdk/VendingMachineSDKImpl.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/waterfountainmachine/app/hardware/sdk/VendingMachineSDKImpl.kt" />
              <option name="originalContent" value="&#10;&#10;" />
              <option name="updatedContent" value="package com.waterfountainmachine.app.hardware.sdk&#10;&#10;import kotlinx.coroutines.TimeoutCancellationException&#10;import kotlinx.coroutines.withTimeout&#10;import java.nio.ByteBuffer&#10;import java.nio.ByteOrder&#10;&#10;/**&#10; * Implementation of VendingMachineSDK&#10; */&#10;class VendingMachineSDKImpl(&#10;    private val serialCommunicator: SerialCommunicator,&#10;    private val commandTimeoutMs: Long = 5000,&#10;    private val statusPollingIntervalMs: Long = 200,&#10;    private val maxStatusPollingAttempts: Int = 10&#10;) : VendingMachineSDK {&#10;&#10;    override suspend fun connect(config: SerialConfig): Boolean {&#10;        return serialCommunicator.connect(config)&#10;    }&#10;&#10;    override suspend fun disconnect() {&#10;        serialCommunicator.disconnect()&#10;    }&#10;&#10;    override fun isConnected(): Boolean {&#10;        return serialCommunicator.isConnected()&#10;    }&#10;&#10;    override suspend fun getDeviceId(): Result&lt;String&gt; {&#10;        return try {&#10;            if (!isConnected()) {&#10;                return Result.failure(VmcException.ConnectionException(&quot;Not connected to VMC&quot;))&#10;            }&#10;&#10;            val command = VmcCommandBuilder.getDeviceId()&#10;            val sendSuccess = serialCommunicator.sendData(command.toByteArray())&#10;            if (!sendSuccess) {&#10;                return Result.failure(VmcException.CommunicationException(&quot;Failed to send command&quot;))&#10;            }&#10;&#10;            val response = withTimeout(commandTimeoutMs) {&#10;                serialCommunicator.readData(commandTimeoutMs)&#10;            } ?: return Result.failure(VmcException.TimeoutException(&quot;No response received&quot;))&#10;&#10;            val responseFrame = ProtocolFrameParser.parse(response)&#10;                ?: return Result.failure(VmcException.ProtocolException(&quot;Invalid response format&quot;))&#10;&#10;            if (responseFrame.command != VmcCommands.GET_DEVICE_ID) {&#10;                return Result.failure(VmcException.ProtocolException(&quot;Unexpected response command&quot;))&#10;            }&#10;&#10;            val deviceId = String(responseFrame.data, Charsets.UTF_8).trim('\u0000')&#10;            Result.success(deviceId)&#10;        } catch (e: TimeoutCancellationException) {&#10;            Result.failure(VmcException.TimeoutException(&quot;Command timed out&quot;))&#10;        } catch (e: Exception) {&#10;            Result.failure(VmcException.CommunicationException(&quot;Communication error: ${e.message}&quot;))&#10;        }&#10;    }&#10;&#10;    override suspend fun sendDeliveryCommand(slot: Int, quantity: Int): Result&lt;VmcResponse.DeliveryResponse&gt; {&#10;        return try {&#10;            if (slot &lt; 1 || slot &gt; 255) {&#10;                throw IllegalArgumentException(&quot;Slot must be between 1 and 255&quot;)&#10;            }&#10;            if (quantity &lt; 1 || quantity &gt; 255) {&#10;                throw IllegalArgumentException(&quot;Quantity must be between 1 and 255&quot;)&#10;            }&#10;&#10;            if (!isConnected()) {&#10;                return Result.failure(VmcException.ConnectionException(&quot;Not connected to VMC&quot;))&#10;            }&#10;&#10;            val command = VmcCommandBuilder.deliveryCommand(slot.toByte(), quantity.toByte())&#10;            val sendSuccess = serialCommunicator.sendData(command.toByteArray())&#10;            if (!sendSuccess) {&#10;                return Result.failure(VmcException.CommunicationException(&quot;Failed to send command&quot;))&#10;            }&#10;&#10;            val response = withTimeout(commandTimeoutMs) {&#10;                serialCommunicator.readData(commandTimeoutMs)&#10;            } ?: return Result.failure(VmcException.TimeoutException(&quot;No response received&quot;))&#10;&#10;            val responseFrame = ProtocolFrameParser.parse(response)&#10;                ?: return Result.failure(VmcException.ProtocolException(&quot;Invalid response format&quot;))&#10;&#10;            if (responseFrame.command != VmcCommands.DELIVERY_COMMAND) {&#10;                return Result.failure(VmcException.ProtocolException(&quot;Unexpected response command&quot;))&#10;            }&#10;&#10;            if (responseFrame.data.size &lt; 2) {&#10;                return Result.failure(VmcException.ProtocolException(&quot;Invalid delivery response data&quot;))&#10;            }&#10;&#10;            val deliveryResponse = VmcResponse.DeliveryResponse(&#10;                cargoLane = responseFrame.data[0],&#10;                quantity = responseFrame.data[1]&#10;            )&#10;            Result.success(deliveryResponse)&#10;        } catch (e: TimeoutCancellationException) {&#10;            Result.failure(VmcException.TimeoutException(&quot;Command timed out&quot;))&#10;        } catch (e: Exception) {&#10;            Result.failure(VmcException.CommunicationException(&quot;Communication error: ${e.message}&quot;))&#10;        }&#10;    }&#10;&#10;    override suspend fun queryDeliveryStatus(slot: Int, quantity: Int): Result&lt;VmcResponse.StatusResponse&gt; {&#10;        return try {&#10;            if (!isConnected()) {&#10;                return Result.failure(VmcException.ConnectionException(&quot;Not connected to VMC&quot;))&#10;            }&#10;&#10;            val command = VmcCommandBuilder.queryDeliveryStatus(slot.toByte(), quantity.toByte())&#10;            val sendSuccess = serialCommunicator.sendData(command.toByteArray())&#10;            if (!sendSuccess) {&#10;                return Result.failure(VmcException.CommunicationException(&quot;Failed to send command&quot;))&#10;            }&#10;&#10;            val response = withTimeout(commandTimeoutMs) {&#10;                serialCommunicator.readData(commandTimeoutMs)&#10;            } ?: return Result.failure(VmcException.TimeoutException(&quot;No response received&quot;))&#10;&#10;            val responseFrame = ProtocolFrameParser.parse(response)&#10;                ?: return Result.failure(VmcException.ProtocolException(&quot;Invalid response format&quot;))&#10;&#10;            if (responseFrame.command != VmcCommands.QUERY_DELIVERY_STATUS) {&#10;                return Result.failure(VmcException.ProtocolException(&quot;Unexpected response command&quot;))&#10;            }&#10;&#10;            if (responseFrame.data.isEmpty()) {&#10;                return Result.failure(VmcException.ProtocolException(&quot;Invalid status response data&quot;))&#10;            }&#10;&#10;            val status = when (responseFrame.data[0]) {&#10;                VmcStatus.SUCCESS -&gt; VmcResponse.DeliveryStatus.SUCCESS&#10;                VmcStatus.FAILURE -&gt; VmcResponse.DeliveryStatus.FAILURE&#10;                VmcStatus.PENDING -&gt; VmcResponse.DeliveryStatus.PENDING&#10;                else -&gt; VmcResponse.DeliveryStatus.UNKNOWN&#10;            }&#10;&#10;            val statusResponse = VmcResponse.StatusResponse(&#10;                status = status,&#10;                cargoLane = if (responseFrame.data.size &gt; 1) responseFrame.data[1] else 0,&#10;                quantity = if (responseFrame.data.size &gt; 2) responseFrame.data[2] else 0&#10;            )&#10;            Result.success(statusResponse)&#10;        } catch (e: TimeoutCancellationException) {&#10;            Result.failure(VmcException.TimeoutException(&quot;Command timed out&quot;))&#10;        } catch (e: Exception) {&#10;            Result.failure(VmcException.CommunicationException(&quot;Communication error: ${e.message}&quot;))&#10;        }&#10;    }&#10;&#10;    override suspend fun removeFault(): Result&lt;VmcResponse.StatusResponse&gt; {&#10;        return try {&#10;            if (!isConnected()) {&#10;                return Result.failure(VmcException.ConnectionException(&quot;Not connected to VMC&quot;))&#10;            }&#10;&#10;            val command = VmcCommandBuilder.removeFault()&#10;            val sendSuccess = serialCommunicator.sendData(command.toByteArray())&#10;            if (!sendSuccess) {&#10;                return Result.failure(VmcException.CommunicationException(&quot;Failed to send command&quot;))&#10;            }&#10;&#10;            val response = withTimeout(commandTimeoutMs) {&#10;                serialCommunicator.readData(commandTimeoutMs)&#10;            } ?: return Result.failure(VmcException.TimeoutException(&quot;No response received&quot;))&#10;&#10;            val responseFrame = ProtocolFrameParser.parse(response)&#10;                ?: return Result.failure(VmcException.ProtocolException(&quot;Invalid response format&quot;))&#10;&#10;            if (responseFrame.command != VmcCommands.REMOVE_FAULT) {&#10;                return Result.failure(VmcException.ProtocolException(&quot;Unexpected response command&quot;))&#10;            }&#10;&#10;            val status = if (responseFrame.data.isNotEmpty()) {&#10;                when (responseFrame.data[0]) {&#10;                    VmcStatus.SUCCESS -&gt; VmcResponse.DeliveryStatus.SUCCESS&#10;                    VmcStatus.FAILURE -&gt; VmcResponse.DeliveryStatus.FAILURE&#10;                    else -&gt; VmcResponse.DeliveryStatus.UNKNOWN&#10;                }&#10;            } else {&#10;                VmcResponse.DeliveryStatus.SUCCESS&#10;            }&#10;&#10;            val statusResponse = VmcResponse.StatusResponse(&#10;                status = status,&#10;                cargoLane = 0,&#10;                quantity = 0&#10;            )&#10;            Result.success(statusResponse)&#10;        } catch (e: TimeoutCancellationException) {&#10;            Result.failure(VmcException.TimeoutException(&quot;Command timed out&quot;))&#10;        } catch (e: Exception) {&#10;            Result.failure(VmcException.CommunicationException(&quot;Communication error: ${e.message}&quot;))&#10;        }&#10;    }&#10;&#10;    override suspend fun queryBalance(): Result&lt;Int&gt; {&#10;        return try {&#10;            if (!isConnected()) {&#10;                return Result.failure(VmcException.ConnectionException(&quot;Not connected to VMC&quot;))&#10;            }&#10;&#10;            val command = VmcCommandBuilder.queryBalance()&#10;            val sendSuccess = serialCommunicator.sendData(command.toByteArray())&#10;            if (!sendSuccess) {&#10;                return Result.failure(VmcException.CommunicationException(&quot;Failed to send command&quot;))&#10;            }&#10;&#10;            val response = withTimeout(commandTimeoutMs) {&#10;                serialCommunicator.readData(commandTimeoutMs)&#10;            } ?: return Result.failure(VmcException.TimeoutException(&quot;No response received&quot;))&#10;&#10;            val responseFrame = ProtocolFrameParser.parse(response)&#10;                ?: return Result.failure(VmcException.ProtocolException(&quot;Invalid response format&quot;))&#10;&#10;            if (responseFrame.command != VmcCommands.QUERY_BALANCE) {&#10;                return Result.failure(VmcException.ProtocolException(&quot;Unexpected response command&quot;))&#10;            }&#10;&#10;            if (responseFrame.data.size &lt; 4) {&#10;                return Result.failure(VmcException.ProtocolException(&quot;Invalid balance response data&quot;))&#10;            }&#10;&#10;            // Parse balance from little-endian bytes&#10;            val balance = ByteBuffer.wrap(responseFrame.data).order(ByteOrder.LITTLE_ENDIAN).int&#10;            Result.success(balance)&#10;        } catch (e: TimeoutCancellationException) {&#10;            Result.failure(VmcException.TimeoutException(&quot;Command timed out&quot;))&#10;        } catch (e: Exception) {&#10;            Result.failure(VmcException.CommunicationException(&quot;Communication error: ${e.message}&quot;))&#10;        }&#10;    }&#10;&#10;    override suspend fun clearFaults(): Result&lt;Boolean&gt; {&#10;        return try {&#10;            if (!isConnected()) {&#10;                return Result.failure(VmcException.ConnectionException(&quot;Not connected to VMC&quot;))&#10;            }&#10;&#10;            val command = VmcCommandBuilder.clearFaults()&#10;            val sendSuccess = serialCommunicator.sendData(command.toByteArray())&#10;            if (!sendSuccess) {&#10;                return Result.failure(VmcException.CommunicationException(&quot;Failed to send command&quot;))&#10;            }&#10;&#10;            val response = withTimeout(commandTimeoutMs) {&#10;                serialCommunicator.readData(commandTimeoutMs)&#10;            } ?: return Result.failure(VmcException.TimeoutException(&quot;No response received&quot;))&#10;&#10;            val responseFrame = ProtocolFrameParser.parse(response)&#10;                ?: return Result.failure(VmcException.ProtocolException(&quot;Invalid response format&quot;))&#10;&#10;            if (responseFrame.command != VmcCommands.CLEAR_FAULTS) {&#10;                return Result.failure(VmcException.ProtocolException(&quot;Unexpected response command&quot;))&#10;            }&#10;&#10;            val success = responseFrame.data.isNotEmpty() &amp;&amp; responseFrame.data[0] == VmcStatus.SUCCESS&#10;            Result.success(success)&#10;        } catch (e: TimeoutCancellationException) {&#10;            Result.failure(VmcException.TimeoutException(&quot;Command timed out&quot;))&#10;        } catch (e: Exception) {&#10;            Result.failure(VmcException.CommunicationException(&quot;Communication error: ${e.message}&quot;))&#10;        }&#10;    }&#10;&#10;    override suspend fun dispenseWater(slot: Int): Result&lt;VmcResponse.DeliveryResponse&gt; {&#10;        return try {&#10;            if (slot &lt; 1 || slot &gt; 255) {&#10;                throw IllegalArgumentException(&quot;Slot must be between 1 and 255&quot;)&#10;            }&#10;&#10;            if (!isConnected()) {&#10;                return Result.failure(VmcException.ConnectionException(&quot;Not connected to VMC&quot;))&#10;            }&#10;&#10;            val command = VmcCommandBuilder.dispenseWater(slot.toByte())&#10;            val sendSuccess = serialCommunicator.sendData(command.toByteArray())&#10;            if (!sendSuccess) {&#10;                return Result.failure(VmcException.CommunicationException(&quot;Failed to send command&quot;))&#10;            }&#10;&#10;            val response = withTimeout(commandTimeoutMs) {&#10;                serialCommunicator.readData(commandTimeoutMs)&#10;            } ?: return Result.failure(VmcException.TimeoutException(&quot;No response received&quot;))&#10;&#10;            val responseFrame = ProtocolFrameParser.parse(response)&#10;                ?: return Result.failure(VmcException.ProtocolException(&quot;Invalid response format&quot;))&#10;&#10;            if (responseFrame.command != VmcCommands.DISPENSE_WATER) {&#10;                return Result.failure(VmcException.ProtocolException(&quot;Unexpected response command&quot;))&#10;            }&#10;&#10;            if (responseFrame.data.size &lt; 2) {&#10;                return Result.failure(VmcException.ProtocolException(&quot;Invalid dispense response data&quot;))&#10;            }&#10;&#10;            val deliveryResponse = VmcResponse.DeliveryResponse(&#10;                cargoLane = responseFrame.data[0],&#10;                quantity = responseFrame.data[1]&#10;            )&#10;            Result.success(deliveryResponse)&#10;        } catch (e: TimeoutCancellationException) {&#10;            Result.failure(VmcException.TimeoutException(&quot;Command timed out&quot;))&#10;        } catch (e: Exception) {&#10;            Result.failure(VmcException.CommunicationException(&quot;Communication error: ${e.message}&quot;))&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/waterfountainmachine/app/hardware/sdk/VmcCommandBuilder.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/waterfountainmachine/app/hardware/sdk/VmcCommandBuilder.kt" />
              <option name="updatedContent" value="package com.waterfountainmachine.app.hardware.sdk&#10;&#10;/**&#10; * Builder for VMC command frames&#10; */&#10;object VmcCommandBuilder {&#10;    &#10;    fun getDeviceId(): ProtocolFrame {&#10;        return ProtocolFrameBuilder()&#10;            .appHeader()&#10;            .command(VmcCommands.GET_DEVICE_ID)&#10;            .dataBytes(0xAD.toByte())&#10;            .build()&#10;    }&#10;    &#10;    fun deliveryCommand(cargoLane: Byte, quantity: Byte = 1): ProtocolFrame {&#10;        return ProtocolFrameBuilder()&#10;            .appHeader()&#10;            .command(VmcCommands.DELIVERY_COMMAND)&#10;            .dataBytes(cargoLane, quantity)&#10;            .build()&#10;    }&#10;    &#10;    fun queryDeliveryStatus(cargoLane: Byte, quantity: Byte = 1): ProtocolFrame {&#10;        return ProtocolFrameBuilder()&#10;            .appHeader()&#10;            .command(VmcCommands.QUERY_DELIVERY_STATUS)&#10;            .dataBytes(cargoLane, quantity)&#10;            .build()&#10;    }&#10;    &#10;    fun removeFault(): ProtocolFrame {&#10;        return ProtocolFrameBuilder()&#10;            .appHeader()&#10;            .command(VmcCommands.REMOVE_FAULT)&#10;            .dataBytes(0xFF.toByte())&#10;            .build()&#10;    }&#10;    &#10;    fun queryBalance(): ProtocolFrame {&#10;        return ProtocolFrameBuilder()&#10;            .appHeader()&#10;            .command(VmcCommands.QUERY_BALANCE)&#10;            .dataBytes(0x00.toByte())&#10;            .build()&#10;    }&#10;    &#10;    fun clearFaults(): ProtocolFrame {&#10;        return ProtocolFrameBuilder()&#10;            .appHeader()&#10;            .command(VmcCommands.CLEAR_FAULTS)&#10;            .dataBytes(0xFF.toByte())&#10;            .build()&#10;    }&#10;    &#10;    fun dispenseWater(slot: Byte): ProtocolFrame {&#10;        return ProtocolFrameBuilder()&#10;            .appHeader()&#10;            .command(VmcCommands.DISPENSE_WATER)&#10;            .dataBytes(slot)&#10;            .build()&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/anim/material_slide_in_left.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/anim/material_slide_in_left.xml" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;&#10;    &lt;!-- Slide in from left with scale and fade (return animation) --&gt;&#10;    &lt;translate&#10;        android:fromXDelta=&quot;-30%p&quot;&#10;        android:toXDelta=&quot;0&quot;&#10;        android:duration=&quot;400&quot;&#10;        android:interpolator=&quot;@android:anim/accelerate_decelerate_interpolator&quot;/&gt;&#10;    &#10;    &lt;scale&#10;        android:fromXScale=&quot;0.95&quot;&#10;        android:toXScale=&quot;1.0&quot;&#10;        android:fromYScale=&quot;0.95&quot;&#10;        android:toYScale=&quot;1.0&quot;&#10;        android:pivotX=&quot;50%&quot;&#10;        android:pivotY=&quot;50%&quot;&#10;        android:duration=&quot;400&quot;&#10;        android:interpolator=&quot;@android:anim/accelerate_decelerate_interpolator&quot;/&gt;&#10;    &#10;    &lt;alpha&#10;        android:fromAlpha=&quot;0.3&quot;&#10;        android:toAlpha=&quot;1.0&quot;&#10;        android:duration=&quot;300&quot;&#10;        android:interpolator=&quot;@android:anim/accelerate_interpolator&quot;/&gt;&#10;&lt;/set&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/anim/material_slide_in_right.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/anim/material_slide_in_right.xml" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;&#10;    &lt;!-- Slide in from right with scale and fade --&gt;&#10;    &lt;translate&#10;        android:fromXDelta=&quot;50%p&quot;&#10;        android:toXDelta=&quot;0&quot;&#10;        android:duration=&quot;400&quot;&#10;        android:interpolator=&quot;@android:anim/accelerate_decelerate_interpolator&quot;/&gt;&#10;    &#10;    &lt;scale&#10;        android:fromXScale=&quot;0.95&quot;&#10;        android:toXScale=&quot;1.0&quot;&#10;        android:fromYScale=&quot;0.95&quot;&#10;        android:toYScale=&quot;1.0&quot;&#10;        android:pivotX=&quot;50%&quot;&#10;        android:pivotY=&quot;50%&quot;&#10;        android:duration=&quot;400&quot;&#10;        android:interpolator=&quot;@android:anim/accelerate_decelerate_interpolator&quot;/&gt;&#10;    &#10;    &lt;alpha&#10;        android:fromAlpha=&quot;0.0&quot;&#10;        android:toAlpha=&quot;1.0&quot;&#10;        android:duration=&quot;300&quot;&#10;        android:interpolator=&quot;@android:anim/accelerate_interpolator&quot;/&gt;&#10;&lt;/set&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/anim/material_slide_out_left.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/anim/material_slide_out_left.xml" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;&#10;    &lt;!-- Slide out to left with scale and fade --&gt;&#10;    &lt;translate&#10;        android:fromXDelta=&quot;0&quot;&#10;        android:toXDelta=&quot;-30%p&quot;&#10;        android:duration=&quot;400&quot;&#10;        android:interpolator=&quot;@android:anim/accelerate_decelerate_interpolator&quot;/&gt;&#10;    &#10;    &lt;scale&#10;        android:fromXScale=&quot;1.0&quot;&#10;        android:toXScale=&quot;0.95&quot;&#10;        android:fromYScale=&quot;1.0&quot;&#10;        android:toYScale=&quot;0.95&quot;&#10;        android:pivotX=&quot;50%&quot;&#10;        android:pivotY=&quot;50%&quot;&#10;        android:duration=&quot;400&quot;&#10;        android:interpolator=&quot;@android:anim/accelerate_decelerate_interpolator&quot;/&gt;&#10;    &#10;    &lt;alpha&#10;        android:fromAlpha=&quot;1.0&quot;&#10;        android:toAlpha=&quot;0.3&quot;&#10;        android:duration=&quot;350&quot;&#10;        android:interpolator=&quot;@android:anim/decelerate_interpolator&quot;/&gt;&#10;&lt;/set&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/anim/zoom_in_back.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/anim/zoom_in_back.xml" />
              <option name="originalContent" value="&#10;&#10;" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    android:duration=&quot;350&quot;&#10;    android:interpolator=&quot;@android:anim/accelerate_decelerate_interpolator&quot;&gt;&#10;&#10;    &lt;!-- Scale down the screen coming back --&gt;&#10;    &lt;scale&#10;        android:fromXScale=&quot;0.85&quot;&#10;        android:toXScale=&quot;1.0&quot;&#10;        android:fromYScale=&quot;0.85&quot;&#10;        android:toYScale=&quot;1.0&quot;&#10;        android:pivotX=&quot;50%&quot;&#10;        android:pivotY=&quot;50%&quot;&#10;        android:duration=&quot;300&quot;&#10;        android:interpolator=&quot;@android:anim/decelerate_interpolator&quot; /&gt;&#10;&#10;&lt;/set&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/anim/zoom_in_fade.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/anim/zoom_in_fade.xml" />
              <option name="originalContent" value="&#10;&#10;&#10;" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;scale xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    android:fromXScale=&quot;1.15&quot;&#10;    android:toXScale=&quot;1.0&quot;&#10;    android:fromYScale=&quot;1.15&quot;&#10;    android:toYScale=&quot;1.0&quot;&#10;    android:pivotX=&quot;50%&quot;&#10;    android:pivotY=&quot;50%&quot;&#10;    android:duration=&quot;300&quot;&#10;    android:interpolator=&quot;@android:anim/decelerate_interpolator&quot; /&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/anim/zoom_out_back.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/anim/zoom_out_back.xml" />
              <option name="originalContent" value="&#10;&#10;" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;scale xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    android:fromXScale=&quot;1.0&quot;&#10;    android:toXScale=&quot;1.15&quot;&#10;    android:fromYScale=&quot;1.0&quot;&#10;    android:toYScale=&quot;1.15&quot;&#10;    android:pivotX=&quot;50%&quot;&#10;    android:pivotY=&quot;50%&quot;&#10;    android:duration=&quot;300&quot;&#10;    android:interpolator=&quot;@android:anim/accelerate_interpolator&quot; /&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/anim/zoom_out_fade.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/anim/zoom_out_fade.xml" />
              <option name="originalContent" value="&#10;&#10;&#10;" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;scale xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    android:fromXScale=&quot;1.0&quot;&#10;    android:toXScale=&quot;0.85&quot;&#10;    android:fromYScale=&quot;1.0&quot;&#10;    android:toYScale=&quot;0.85&quot;&#10;    android:pivotX=&quot;50%&quot;&#10;    android:pivotY=&quot;50%&quot;&#10;    android:duration=&quot;300&quot;&#10;    android:interpolator=&quot;@android:anim/accelerate_interpolator&quot; /&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/drawable/card_disabled_background.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/drawable/card_disabled_background.xml" />
              <option name="originalContent" value="&#10;&#10;&#10;&#10;" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;&#10;    &lt;solid android:color=&quot;#6B7280&quot; /&gt;&#10;    &lt;corners android:radius=&quot;24dp&quot; /&gt;&#10;    &lt;stroke &#10;        android:width=&quot;2dp&quot; &#10;        android:color=&quot;#4B5563&quot; /&gt;&#10;&lt;/shape&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/drawable/card_enhanced_shadow_background.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/drawable/card_enhanced_shadow_background.xml" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;layer-list xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;&#10;    &lt;!-- Shadow layer --&gt;&#10;    &lt;item android:top=&quot;4dp&quot; android:left=&quot;2dp&quot; android:right=&quot;6dp&quot; android:bottom=&quot;8dp&quot;&gt;&#10;        &lt;shape&gt;&#10;            &lt;solid android:color=&quot;#1A000000&quot; /&gt;&#10;            &lt;corners android:radius=&quot;24dp&quot; /&gt;&#10;        &lt;/shape&gt;&#10;    &lt;/item&gt;&#10;    &lt;!-- Card background --&gt;&#10;    &lt;item android:top=&quot;0dp&quot; android:left=&quot;0dp&quot; android:right=&quot;4dp&quot; android:bottom=&quot;4dp&quot;&gt;&#10;        &lt;shape&gt;&#10;            &lt;solid android:color=&quot;#FFFFFF&quot; /&gt;&#10;            &lt;corners android:radius=&quot;24dp&quot; /&gt;&#10;            &lt;stroke&#10;                android:width=&quot;1dp&quot;&#10;                android:color=&quot;#E5E7EB&quot; /&gt;&#10;        &lt;/shape&gt;&#10;    &lt;/item&gt;&#10;&lt;/layer-list&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/drawable/card_gradient_background.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/drawable/card_gradient_background.xml" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;&#10;    &lt;gradient&#10;        android:startColor=&quot;#FFFFFF&quot;&#10;        android:endColor=&quot;#F8FAFF&quot;&#10;        android:angle=&quot;135&quot; /&gt;&#10;    &lt;corners android:radius=&quot;24dp&quot; /&gt;&#10;    &lt;stroke&#10;        android:width=&quot;2dp&quot;&#10;        android:color=&quot;#E1E5F0&quot; /&gt;&#10;&lt;/shape&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/drawable/card_white_background.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/drawable/card_white_background.xml" />
              <option name="originalContent" value="&#10;&#10;" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;&#10;    &lt;solid android:color=&quot;#F8FAFC&quot; /&gt;&#10;    &lt;corners android:radius=&quot;24dp&quot; /&gt;&#10;    &lt;stroke&#10;        android:width=&quot;2dp&quot;&#10;        android:color=&quot;#E2E8F0&quot; /&gt;&#10;&lt;/shape&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/drawable/coming_soon_rounded_background.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/drawable/coming_soon_rounded_background.xml" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;&#10;    &lt;solid android:color=&quot;#80FFFFFF&quot; /&gt;&#10;    &lt;corners android:radius=&quot;16dp&quot; /&gt;&#10;&lt;/shape&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/drawable/ic_pin_code.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/drawable/ic_pin_code.xml" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;vector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    android:width=&quot;24dp&quot;&#10;    android:height=&quot;24dp&quot;&#10;    android:viewportWidth=&quot;24&quot;&#10;    android:viewportHeight=&quot;24&quot;&gt;&#10;    &lt;path&#10;        android:fillColor=&quot;#FF000000&quot;&#10;        android:pathData=&quot;M12,1L3,5V11C3,16.55 6.84,21.74 12,23C17.16,21.74 21,16.55 21,11V5L12,1M12,7C13.4,7 14.8,8.6 14.8,10V11H16.2V16H7.8V11H9.2V10C9.2,8.6 10.6,7 12,7M12,8.2C11.2,8.2 10.4,8.7 10.4,10V11H13.6V10C13.6,8.7 12.8,8.2 12,8.2Z&quot;/&gt;&#10;&lt;/vector&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/drawable/overlay_rounded_background.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/drawable/overlay_rounded_background.xml" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;&#10;    &lt;solid android:color=&quot;#AA000000&quot; /&gt;&#10;    &lt;corners android:radius=&quot;24dp&quot; /&gt;&#10;&lt;/shape&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/gradle/libs.versions.toml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/gradle/libs.versions.toml" />
              <option name="originalContent" value="[versions]&#10;agp = &quot;8.11.2&quot;&#10;kotlin = &quot;2.0.21&quot;&#10;coreKtx = &quot;1.16.0&quot;&#10;junit = &quot;4.13.2&quot;&#10;junitVersion = &quot;1.2.1&quot;&#10;espressoCore = &quot;3.6.1&quot;&#10;lifecycleRuntimeKtx = &quot;2.9.1&quot;&#10;activityCompose = &quot;1.10.1&quot;&#10;composeBom = &quot;2024.09.00&quot;&#10;&#10;[libraries]&#10;androidx-core-ktx = { group = &quot;androidx.core&quot;, name = &quot;core-ktx&quot;, version.ref = &quot;coreKtx&quot; }&#10;junit = { group = &quot;junit&quot;, name = &quot;junit&quot;, version.ref = &quot;junit&quot; }&#10;androidx-junit = { group = &quot;androidx.test.ext&quot;, name = &quot;junit&quot;, version.ref = &quot;junitVersion&quot; }&#10;androidx-espresso-core = { group = &quot;androidx.test.espresso&quot;, name = &quot;espresso-core&quot;, version.ref = &quot;espressoCore&quot; }&#10;androidx-lifecycle-runtime-ktx = { group = &quot;androidx.lifecycle&quot;, name = &quot;lifecycle-runtime-ktx&quot;, version.ref = &quot;lifecycleRuntimeKtx&quot; }&#10;androidx-activity-compose = { group = &quot;androidx.activity&quot;, name = &quot;activity-compose&quot;, version.ref = &quot;activityCompose&quot; }&#10;androidx-compose-bom = { group = &quot;androidx.compose&quot;, name = &quot;compose-bom&quot;, version.ref = &quot;composeBom&quot; }&#10;androidx-ui = { group = &quot;androidx.compose.ui&quot;, name = &quot;ui&quot; }&#10;androidx-ui-graphics = { group = &quot;androidx.compose.ui&quot;, name = &quot;ui-graphics&quot; }&#10;androidx-ui-tooling = { group = &quot;androidx.compose.ui&quot;, name = &quot;ui-tooling&quot; }&#10;androidx-ui-tooling-preview = { group = &quot;androidx.compose.ui&quot;, name = &quot;ui-tooling-preview&quot; }&#10;androidx-ui-test-manifest = { group = &quot;androidx.compose.ui&quot;, name = &quot;ui-test-manifest&quot; }&#10;androidx-ui-test-junit4 = { group = &quot;androidx.compose.ui&quot;, name = &quot;ui-test-junit4&quot; }&#10;androidx-material3 = { group = &quot;androidx.compose.material3&quot;, name = &quot;material3&quot; }&#10;&#10;[plugins]&#10;android-application = { id = &quot;com.android.application&quot;, version.ref = &quot;agp&quot; }&#10;kotlin-android = { id = &quot;org.jetbrains.kotlin.android&quot;, version.ref = &quot;kotlin&quot; }&#10;kotlin-compose = { id = &quot;org.jetbrains.kotlin.plugin.compose&quot;, version.ref = &quot;kotlin&quot; }&#10;&#10;" />
              <option name="updatedContent" value="[versions]&#10;agp = &quot;8.5.2&quot;&#10;kotlin = &quot;1.9.25&quot;&#10;coreKtx = &quot;1.13.1&quot;&#10;junit = &quot;4.13.2&quot;&#10;junitVersion = &quot;1.2.1&quot;&#10;espressoCore = &quot;3.6.1&quot;&#10;lifecycleRuntimeKtx = &quot;2.8.4&quot;&#10;activityCompose = &quot;1.9.1&quot;&#10;composeBom = &quot;2024.06.00&quot;&#10;mockito = &quot;5.4.0&quot;&#10;mockitoKotlin = &quot;5.1.0&quot;&#10;coroutinesTest = &quot;1.7.3&quot;&#10;&#10;[libraries]&#10;androidx-core-ktx = { group = &quot;androidx.core&quot;, name = &quot;core-ktx&quot;, version.ref = &quot;coreKtx&quot; }&#10;junit = { group = &quot;junit&quot;, name = &quot;junit&quot;, version.ref = &quot;junit&quot; }&#10;androidx-junit = { group = &quot;androidx.test.ext&quot;, name = &quot;junit&quot;, version.ref = &quot;junitVersion&quot; }&#10;androidx-espresso-core = { group = &quot;androidx.test.espresso&quot;, name = &quot;espresso-core&quot;, version.ref = &quot;espressoCore&quot; }&#10;androidx-lifecycle-runtime-ktx = { group = &quot;androidx.lifecycle&quot;, name = &quot;lifecycle-runtime-ktx&quot;, version.ref = &quot;lifecycleRuntimeKtx&quot; }&#10;androidx-activity-compose = { group = &quot;androidx.activity&quot;, name = &quot;activity-compose&quot;, version.ref = &quot;activityCompose&quot; }&#10;androidx-compose-bom = { group = &quot;androidx.compose&quot;, name = &quot;compose-bom&quot;, version.ref = &quot;composeBom&quot; }&#10;androidx-ui = { group = &quot;androidx.compose.ui&quot;, name = &quot;ui&quot; }&#10;androidx-ui-graphics = { group = &quot;androidx.compose.ui&quot;, name = &quot;ui-graphics&quot; }&#10;androidx-ui-tooling = { group = &quot;androidx.compose.ui&quot;, name = &quot;ui-tooling&quot; }&#10;androidx-ui-tooling-preview = { group = &quot;androidx.compose.ui&quot;, name = &quot;ui-tooling-preview&quot; }&#10;androidx-ui-test-manifest = { group = &quot;androidx.compose.ui&quot;, name = &quot;ui-test-manifest&quot; }&#10;androidx-ui-test-junit4 = { group = &quot;androidx.compose.ui&quot;, name = &quot;ui-test-junit4&quot; }&#10;androidx-material3 = { group = &quot;androidx.compose.material3&quot;, name = &quot;material3&quot; }&#10;&#10;# Testing libraries&#10;mockito-core = { group = &quot;org.mockito&quot;, name = &quot;mockito-core&quot;, version.ref = &quot;mockito&quot; }&#10;mockito-kotlin = { group = &quot;org.mockito.kotlin&quot;, name = &quot;mockito-kotlin&quot;, version.ref = &quot;mockitoKotlin&quot; }&#10;kotlinx-coroutines-test = { group = &quot;org.jetbrains.kotlinx&quot;, name = &quot;kotlinx-coroutines-test&quot;, version.ref = &quot;coroutinesTest&quot; }&#10;&#10;[plugins]&#10;android-application = { id = &quot;com.android.application&quot;, version.ref = &quot;agp&quot; }&#10;kotlin-android = { id = &quot;org.jetbrains.kotlin.android&quot;, version.ref = &quot;kotlin&quot; }" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/gradle/wrapper/gradle-wrapper.properties">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/gradle/wrapper/gradle-wrapper.properties" />
              <option name="originalContent" value="#Tue Jul 22 22:50:03 PDT 2025&#10;distributionBase=GRADLE_USER_HOME&#10;distributionPath=wrapper/dists&#10;distributionUrl=https\://services.gradle.org/distributions/gradle-8.13-bin.zip&#10;zipStoreBase=GRADLE_USER_HOME&#10;zipStorePath=wrapper/dists&#10;" />
              <option name="updatedContent" value="#Tue Jul 22 22:50:03 PDT 2025&#10;distributionBase=GRADLE_USER_HOME&#10;distributionPath=wrapper/dists&#10;distributionUrl=https\://services.gradle.org/distributions/gradle-8.7-bin.zip&#10;zipStoreBase=GRADLE_USER_HOME&#10;zipStorePath=wrapper/dists" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>